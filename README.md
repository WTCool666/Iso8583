****
### Introduce iso8583、packaging iso8583 data、parse iso8583（iso8583介绍，iso8583数据解析和数据组包）
****
## 目录
* [ISO8583](#ISO8583)
* [TPDU](#TPDU)
* [位图解析](#位图解析)
* [ISO8583组包格式](#ISO8583组包格式)
* [用法](#用法)
    * 解包
    * 组包
* [参考链接](#参考链接)
* [联系方式](#联系方式)

ISO8583
------

全面掌握ISO8583报文


最开始时，金融系统只有IBM这些大的公司来提供设备，象各种主机与终端等。在各个计算机设备之间，需要交换数据。
我们知道数据是通过网络来传送的，而在网络上传送的数据都是基于0或1这样的二进制数据，如果没有对数据进行编码，
则这些数据没有人能够理解，属于没有用的数据。起初的X.25、SDLC以及现在流行的TCP/IP网络协议都提供底层的通讯编码协议，
它们解决了最底层的通讯问题，能够将一串字符从一个地方传送到另一个地方。但是，仅仅传送字符串是没有太大意义的，
怎样来解析字符串代表什么内容是非常重要的，否则传送一些“0123abcd”的字符串也是无用的乱码。

让我们随着时光回到几十年前的某个时刻，假设我们被推到历史的舞台上，由我们来设计一个通用报文协议，来解决金融系统之间的报文交
换，暂且称该协议叫做ISO8583协议。此时，技术是在不断的前行，当初IBM一支独秀的局面好像已经不妙了，各种大小不一的公司都进入金
融行业以求能有所斩获，呈一片百花齐放的局面。我们怎样来设计一个报文协议，能够将这些如雨后春笋般出现的所有公司都纳入进来，其
实也不是一件很简单的事。

我们还是先一步步的来考虑吧。金融行业其实涉及到的数据内容并不是成千上万，无法统计，恰恰相反，是比较少的。我们都可以在心底数
得过来，象交易类型、帐号、帐户类型、密码、交易金额、交易手续费、日期时间、商户代码、2磁3磁数据、交易序列号等，把所有能够总
结出来的都总结起来不过100个左右的数据。那我们可以首先简单的设计ISO8583，定义128个字段，将所有能够考虑到的类似上面提到的“帐
号”等金融数据类型，按照一个顺序排起来，分别对应128个字段中的一个字段。每个数据类型占固定的长度，这个顺序和长度我们都事先定
义好。这样就简单了，要发送一个报文时，就将128个字段按照顺序接起来，然后将接起来的整串数据包发送出去。

任何金融软件收到ISO8583包后，直接按照我们定义的规范解包即可，因为整个报文的128个字段从哪一位到哪一位代表什么，大家都知道，
只要知道你的数据包是ISO8583包即可，我们都已经定义好了。比如第1个字段是“交易类型”，长度为4位，第2个字段位是“帐号”，为19位
等等。接收方就可以先取4位，再取接着的19位，依次类推，直到整个数据包128个字段都解完为止。

其实这种做法真是简单直接，基本上就可以满足需要了。不过我们有几个问题要思考下：
1、 我怎么知道每个字段的数据类型呢，是数字还是字符？
2、 每个传送的报文都把128个字段都传过去，那网络带宽能够承受得了，有时候我可能只需要其中5个字段，结果多收到了123个无用的字段。
3、 如果我某些字段的长度不固定，属于变长怎么办，因为你现在解包是当作数据包每个字段都是固定的，用C语言解包时直接依靠指针取固定长度的一串字符做为一个字段。

我们来一一解决这些问题。

第一个问题简单，我在定义ISO8583时除了定义每个字段表示什么，还规定其内容是数字或是字符等即可。考虑可能出现的类型不过有以下
几种：字母、数字、特殊字符、年月日等时间、二进制数据。比如我对128个字段中的“商户类型”字段定义其长度是15，同时定义其类型为
字母。再精细点，如果“商户类型”里面的数据同时包括数字和字母呢？那我们就定义其类型为字母也可，为数字也可，即一个字段可以同时
属于多个类型。

第二个问题稍微复杂点。其本质就是如果我只传128个字段的5个字段，接收方怎么知道我传了哪几个字段给它了。要是我们把剩下的123全部
填成0或其他特殊标识，标明该字段不需要使用？这种处理方法没有半点用处，没有解决网络带宽的本质问题，还是要传128个字段。

换个思路，我在报文前面加上个包头，包头里面包含的信息能够让别人知道只传了5个字段。怎样设计这个包头，可以这样，我们用16个字节
，即128个bit（一个字节等于8bit）来表示128个字段中的某个字段是否存在。每个bit在计算机的二进制里面不是1就是0，如果是1就表示对
应的字段在本次报文中存在，如果是0就是不存在。这样好了，如果别人接收到了ISO8583报文，可以先根据最前面的报文头，就知道紧接着
报文头后面的报文有哪些字段，没有哪些字段了。比如，我要发送5个字段，分别属于128个字段中的第2、3、6、8、9字段，我就可以将
128bit的报文头填成011001011000000000………..，一共128个bit，后面就全是0了。注意其中第2、3、6、8、9位为1，其他都为0。

有了这个128bit的报文头，我们就可以只发送需要的5个字段了。怎样组织报文？先放上这128bit，即16个字节的头，
然后在头后面放2、3、6、8、9字段，这些字段紧挨在一起，3和6之间也不需要填上4、5这两个字段了。接收方收到这个报文，
它会根据128bit的报文头来解包，它自然知道把第3个字段取出后，就直接在第3字段的后面取第6个字段，每个字段的长度在ISO8583里面都
定义好了，很轻松就把数据包解出来了。

这下好了，为了解决上面的第二问题，我们只是在报文中增加了16个字节的数据，就轻松搞定了，我们把这16个字节称为bit map，即位图，
用来表示某个位是否存在。不过我们再稍微优化一下，考虑到很多时候报文不需要128个字段这么多，其一半64个字段都不一定能够用完。
那我可以将报文头由128bit减到64bit，只有在需要的时候才把剩下的64bit放到报文里面，这样报文长度不又少了8个字节吗？

是个好主意。我们把ISO8583的128个字段中最常见的都放到前64个字段中，那我们可以将处理缩小一倍。这样我一般发送报文时只需
发送64bit，即一个字节的报文头，再加上需要的几个字段就可以了。如果有些报文用到64到128之间的字段呢？这个也好办，我把64bit报文
头的第一位bit用来代表特殊含义，如果该bit为1，则表示64bit后面跟了剩下的64bit报文头；如果第一位bit为0，则表示64bit后面没有跟
剩下的64bit报文头，直接是128个字段中的报文了。那们，接收方会判断一下报头的第一个bit是1还是0，从而知道报文头是
64bit还是128bit了，就可以做相应处理。因为报文头第二个64bit属于有时候有，所以我们叫它Extended bit map扩展位图，
相应的报文头最开始的64bit我们叫它Primary bit map主位图。我们直接把扩展位图固定放到128个字段的第一个字段，
而主位图每个数据包都有，就强制性放在所有128个字段的前面，并不归入128个字段中去。

第三个问题可以考虑这样解决。比如第2个字段是“帐号”，是不定长的，可能有的银行帐号是19位，有的是17位等。
我们定ISO8583规范时可以规定第2个字段是25位，这下足够将19和17的情况都包含进来，但是如果以后出现了30位的怎么办？
那我们现在将字段定为100位。以后超过100位怎么办，况且如果你只有19位的帐号，我们定义了100位，
那81位的数据不是浪费了网络的带宽。看来预先定义一个我们认为比较大的位数是不太好的。

我们这样，对于第2个字段“帐号”，在字段的开头加上“帐号”的长度。比如帐号是0123456789，一共10位，我们变成100123456789，
注意前面多了个10，表示后面的10位为帐号。如果你接触过COM里面的BSTR，应该对这种处理比较熟悉了。接收方收到该字段后，
它知道ISO8583规定第2个字段“帐号”是变长的，所以会先取前面的2位出来，获取其值，此时为长度，
然后根据该长度值知道应该拷贝该字段后面哪几位数据，才是真正的帐号。如果你觉得长度如果只有两位最多只能表示99位长，不太够，
我们也定义可以允许前面3位都为长度的变长字段，这样就有999位长，应该够了吧。在规范里面如果我定义某个字段的属性是“LLVAR”，
你注意了，其中的LL表示长度，VAR表示后面的数据，两个LL表示两位长，最大是99，如果是三位就是“LLLVAR”，最大是999。
这样看我们定义的ISO8583规范文档时直接根据这几个字母就理解某个变长字段的意思了。

该解决的几个问题到这里都解决了，我们来回顾下自己设计的ISO8583规范。其实没有什么，无非是把金融行业可能出现的数据分门别类，
排好顺序，接着把它们连接起来，组成一个报文发送出去而已。其中针对该报文的设计进行了一些优化，引入了bit map位图的概念，
也算是一个不错的想法。

剩下的工作就简单了，我们就直接收集金融行业可能出现的数据字段类型，分成128个字段类型，如果没有到128个这么多就先保留一些下来，
另外考虑到有些人有特殊的要求，我们规定可以将128个字段中的几个字段你自己来定义其内容，也算是一种扩展了。

这样，最后我们就得到了ISO8583规范的那张字段描述表了。想要详细的知道每个字段的含义直接对着表看就可以，比较简单。

TPDU
------

TPDU,全称Transport Protocol Data Unit，是指传送协议数据单元。代表从一个传输实体发送至另一个传输实体的消息。


位图解析
------

如将位图的第一位设为'1'，表示使用扩展位图（128个域），否则表示只使用基本位图（64个域）。
例如：位图：20 00 38 00 00 00 00 34（64个域）。
你把它解开，
排列一下
20 = 0010 0000
00 = 0000 0000
38 = 0011 1000
依次类推，得到一串数字，总共64位
```Java
0010 0000
0000 0000
0011 1000
0000 0000
0000 0000
0000 0000
0000 0000
0011 0100
```
以上数据有多少个1表明需要多少个域的数据，而1的位置表明需要那个域的数据，
以上数据需要3、19、20、21、59、60、62域的数据，以此类推

ISO8583组包格式
------

报文长度(2字节)+TPDU(5字节)+报文头(6字节)+域数据(指令码(0域 2字节)+位图(8/16字节,如果首字节为1,表示使用扩展域，为16字节)+其他域数据)

报文长度：从TPDU-报文结尾

一个域数据对象可以包括：
域长度类型：0-9(定长)、0-99(不定长)、0-999(不定长)
域长度：0-999
域编码类型：BCD、ASCII 、BINARY

其他域数据： 如果 域长度类型是0-9(定长),则其他域数据为：域数据
如果 域长度类型是0-99(不定长),则其他域数据为：计算的1字节域数据长度+域数据
如果 域长度类型是0-999(不定长), 则其他域数据为：计算的2字节域数据长度+域数据


用法
------

### 解包
```Java
	String card="00 ac 60 00 00 00 03 60 31 00 11 43 00 02 00 70 20 04 c0 20 c0 98 15 16 62 14 92 20 00 18 89 24 00 00 00 00 00 00 00 01 10 00 00 01 02 10 00 12 96 c2 d8 29 c0 0f 1b d5 ef d1 aa f8 b3 42 68 3c 32 51 17 ef 95 fe 00 ef ff 83 ec f9 af 58 68 88 55 83 ec f9 af 58 68 88 55 e1 56 01 3a 1b 5e f7 13 30 30 30 30 31 33 32 35 31 30 30 32 36 35 30 30 30 30 30 30 34 33 35 31 35 36 06 ae 97 a8 0a 02 84 04 26 00 00 00 00 00 00 00 00 14 22 00 00 34 00 00 00 00 16 82 ec 27 99 72 f1 8c 94 9b b1 7f 47 11 20 79 0c 36 44 33 39 38 43 39 32";
//		String card="009660000000036031001143000200702004C02"
//				+ "0C0981519621661610100846688700000000000000000100000230210001248725839C868C"
//				+ "AC809870E985AAE5825B9E7B779A4191B7E3A3032303030303831383236303735353435313130303032"
//				+ "313536AB6709ED74209D422600000000000000001422002908000000001649163A2561835591B3838B97"
//				+ "05524F864445324445454536";
	//解析8583数据
//		String card="00 96 60 00 00 00 03 60 31 00 11 43 00 02 00 70 20 04 C0 20 C0 98 15 19 62 16 61 61 01 00 84 66 88 70 00 00 00 00 00 00 00 00 10 00 00 23 02 10 00 12 48 72 58 39 C8 68 CA C8 09 87 0E 98 5A AE 58 25 B9 E7 B7 79 A4 19 1B 7E 3A 30 32 30 30 30 30 38 31 38 32 36 30 37 35 35 34 35 31 31 30 30 30 32 31 35 36 AB 67 09 ED 74 20 9D 42 26 00 00 00 00 00 00 00 00 14 22 00 29 08 00 00 00 00 16 49 16 3A 25 61 83 55 91 B3 83 8B 97 05 52 4F 86 44 45 32 44 45 45 45 36";
	ByteArrayOutputStream outAr=new ByteArrayOutputStream();
	outAr.write(ByteUtils.getByte(card));
	byte[] result = ByteUtils.subArray(outAr.toByteArray(), 13, -1);
	Iso8583Utils utils=new Iso8583Utils();
	System.out.println(utils.parseIso8583Datas(result));	
```

### 组包
```Java
	Map<Integer,String> map=new HashMap<>();	 
	map.put(0,  "0200");
	map.put(2, "6216616101008466887");
	map.put(3, "000000");
	map.put(4, "000000000010");
	map.put(11, "000023");
	map.put(22, "021");
	map.put(25, "00");
	map.put(26, "12");
	map.put(35, "725839c868cac809870e985aae5825b9e7b779a4191b7e3a");
	map.put(41, "02000081");
	map.put(42, "826075545110002");
	map.put(49, "156");
	map.put(52, "ab6709ed74209d42");
	map.put(53, "2600000000000000");
	map.put(60, "22002908000000");
	map.put(62, "49163a2561835591b3838b9705524f86");
//		"da06fbf16d049cee3939c4f04d52342d"
	map.put(64, ByteUtils.getHexStrNoSpli("DE2DEEE6".getBytes()));
	byte[] data = null;
	try {
		data = utils.packageIso8583Datas(map, false);
	} catch (IOException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	System.out.println("原始报文:\n"+card);
```

参考链接
------

[https://baike.baidu.com/item/8583%E5%8D%8F%E8%AE%AE/5754381?fr=aladdin](https://baike.baidu.com/item/8583%E5%8D%8F%E8%AE%AE/5754381?fr=aladdin)。
[http://www.blogjava.net/jjwwhmm/archive/2009/03/31/263041.html](http://www.blogjava.net/jjwwhmm/archive/2009/03/31/263041.html)
[https://wenku.baidu.com/view/d6430445854769eae009581b6bd97f192279bf8b.html](https://wenku.baidu.com/view/d6430445854769eae009581b6bd97f192279bf8b.html)

联系方式
------
[CSDN地址](https://blog.csdn.net/qq_33750826/article/details/53740432)
1262135886@qq.com




